// ËßÜÈ¢ëÊí≠ÊîæÂô®‰∏ªÁªÑ‰ª∂

import React, { useState, useRef, useEffect } from "react";
import type { VideoPlayerProps, PlayerState } from "../../types/video";
import {
  createVideoObjectURL,
  revokeVideoObjectURL,
  calculateProgress,
  calculateTimeFromProgress,
  getPlaybackRateOptions,
  isPictureInPictureSupported,
  isFullscreenSupported,
} from "../../utils/videoUtils";
import { formatTime } from "../../utils/fileUtils";
import "./VideoPlayer.less";

const VideoPlayer: React.FC<VideoPlayerProps> = ({ currentVideo, onVideoEnd, onTimeUpdate }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const progressBarRef = useRef<HTMLDivElement>(null);
  const [objectURL, setObjectURL] = useState<string | null>(null);

  const [playerState, setPlayerState] = useState<PlayerState>({
    currentVideo: null,
    playlist: [],
    currentIndex: -1,
    isPlaying: false,
    volume: 1,
    currentTime: 0,
    duration: 0,
    playbackRate: 1,
  });

  const [showControls, setShowControls] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const controlsTimeoutRef = useRef<number>(null);

  // Êõ¥Êñ∞ÂΩìÂâçËßÜÈ¢ë
  useEffect(() => {
    if (currentVideo) {
      // Ê∏ÖÁêÜ‰πãÂâçÁöÑÂØπË±°URL
      if (objectURL) {
        revokeVideoObjectURL(objectURL);
      }

      // ÂàõÂª∫Êñ∞ÁöÑÂØπË±°URL
      const newObjectURL = createVideoObjectURL(currentVideo);
      setObjectURL(newObjectURL);

      setPlayerState(prev => ({
        ...prev,
        currentVideo,
        currentTime: 0,
        duration: 0,
        isPlaying: false,
      }));
    }

    return () => {
      if (objectURL) {
        revokeVideoObjectURL(objectURL);
      }
    };
  }, [currentVideo]);

  // ËßÜÈ¢ëÂä†ËΩΩÂÆåÊàê
  const handleLoadedMetadata = () => {
    if (videoRef.current) {
      setPlayerState(prev => ({
        ...prev,
        duration: videoRef.current!.duration,
        volume: videoRef.current!.volume,
      }));
    }
  };

  // Êó∂Èó¥Êõ¥Êñ∞
  const handleTimeUpdate = () => {
    if (videoRef.current && !isDragging) {
      const currentTime = videoRef.current.currentTime;
      setPlayerState(prev => ({
        ...prev,
        currentTime,
      }));
      onTimeUpdate(currentTime);
    }
  };

  // Êí≠Êîæ/ÊöÇÂÅú
  const togglePlay = () => {
    if (videoRef.current) {
      if (playerState.isPlaying) {
        videoRef.current.pause();
      } else {
        videoRef.current.play();
      }
    }
  };

  // Êí≠ÊîæÁä∂ÊÄÅÊîπÂèò
  const handlePlay = () => {
    setPlayerState(prev => ({ ...prev, isPlaying: true }));
  };

  const handlePause = () => {
    setPlayerState(prev => ({ ...prev, isPlaying: false }));
  };

  // ËßÜÈ¢ëÁªìÊùü
  const handleEnded = () => {
    setPlayerState(prev => ({ ...prev, isPlaying: false }));
    onVideoEnd();
  };

  // Èü≥ÈáèÊéßÂà∂
  const handleVolumeChange = (volume: number) => {
    if (videoRef.current) {
      videoRef.current.volume = volume;
      setPlayerState(prev => ({ ...prev, volume }));
    }
  };

  // Êí≠ÊîæÈÄüÂ∫¶ÊéßÂà∂
  const handlePlaybackRateChange = (rate: number) => {
    if (videoRef.current) {
      videoRef.current.playbackRate = rate;
      setPlayerState(prev => ({ ...prev, playbackRate: rate }));
    }
  };

  // ËøõÂ∫¶Êù°ÊãñÊãΩ
  const handleProgressMouseDown = (e: React.MouseEvent) => {
    setIsDragging(true);
    handleProgressClick(e);
  };

  const handleProgressClick = (e: React.MouseEvent) => {
    if (progressBarRef.current && videoRef.current) {
      const rect = progressBarRef.current.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const progress = (clickX / rect.width) * 100;
      const newTime = calculateTimeFromProgress(progress, playerState.duration);

      videoRef.current.currentTime = newTime;
      setPlayerState(prev => ({ ...prev, currentTime: newTime }));
    }
  };

  // ÂÖ®Â±èÊéßÂà∂
  const toggleFullscreen = () => {
    if (!isFullscreenSupported()) return;

    if (!isFullscreen) {
      if (containerRef.current?.requestFullscreen) {
        containerRef.current.requestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  };

  // Áîª‰∏≠ÁîªÊéßÂà∂
  const togglePictureInPicture = async () => {
    if (!isPictureInPictureSupported() || !videoRef.current) return;

    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      } else {
        await videoRef.current.requestPictureInPicture();
      }
    } catch (error) {
      console.error("Áîª‰∏≠ÁîªÊ®°ÂºèÂàáÊç¢Â§±Ë¥•:", error);
    }
  };

  // ÈîÆÁõòÂø´Êç∑ÈîÆ
  const handleKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case " ":
        e.preventDefault();
        togglePlay();
        break;
      case "ArrowLeft":
        e.preventDefault();
        if (videoRef.current) {
          videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 10);
        }
        break;
      case "ArrowRight":
        e.preventDefault();
        if (videoRef.current) {
          videoRef.current.currentTime = Math.min(playerState.duration, videoRef.current.currentTime + 10);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        handleVolumeChange(Math.min(1, playerState.volume + 0.1));
        break;
      case "ArrowDown":
        e.preventDefault();
        handleVolumeChange(Math.max(0, playerState.volume - 0.1));
        break;
      case "f":
        e.preventDefault();
        toggleFullscreen();
        break;
    }
  };

  // ÊéßÂà∂Ê†èÊòæÁ§∫/ÈöêËóè
  const showControlsTemporarily = () => {
    setShowControls(true);
    if (controlsTimeoutRef.current) {
      clearTimeout(controlsTimeoutRef.current);
    }
    controlsTimeoutRef.current = setTimeout(() => {
      if (playerState.isPlaying) {
        setShowControls(false);
      }
    }, 3000);
  };

  // ÁõëÂê¨ÂÖ®Â±èÁä∂ÊÄÅÂèòÂåñ
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);

  // Èº†Ê†áÁßªÂä®Êó∂ÊòæÁ§∫ÊéßÂà∂Ê†è
  useEffect(() => {
    const handleMouseMove = () => {
      showControlsTemporarily();
    };

    if (containerRef.current) {
      containerRef.current.addEventListener("mousemove", handleMouseMove);
    }

    return () => {
      if (containerRef.current) {
        containerRef.current.removeEventListener("mousemove", handleMouseMove);
      }
      if (controlsTimeoutRef.current) {
        clearTimeout(controlsTimeoutRef.current);
      }
    };
  }, [playerState.isPlaying]);

  const progress = calculateProgress(playerState.currentTime, playerState.duration);
  const playbackRateOptions = getPlaybackRateOptions();

  return (
    <div ref={containerRef} className={`video-player ${isFullscreen ? "fullscreen" : ""}`} onKeyDown={handleKeyDown} tabIndex={0}>
      {currentVideo ? (
        <>
          <video
            ref={videoRef}
            src={objectURL || ""}
            onLoadedMetadata={handleLoadedMetadata}
            onTimeUpdate={handleTimeUpdate}
            onPlay={handlePlay}
            onPause={handlePause}
            onEnded={handleEnded}
            onClick={togglePlay}
            className='video-element'
          />

          <div className={`video-controls ${showControls ? "visible" : ""}`}>
            {/* ËøõÂ∫¶Êù° */}
            <div ref={progressBarRef} className='progress-container' onMouseDown={handleProgressMouseDown} onClick={handleProgressClick}>
              <div className='progress-bar'>
                <div className='progress-filled' style={{ width: `${progress}%` }} aria-label='Êí≠ÊîæËøõÂ∫¶' />
                <div className='progress-thumb' style={{ left: `${progress}%` }} aria-label='ËøõÂ∫¶ÊªëÂùó' />
              </div>
            </div>

            {/* ÊéßÂà∂ÊåâÈíÆ */}
            <div className='controls-row'>
              <div className='controls-left'>
                <button className='control-btn play-pause' onClick={togglePlay} title={playerState.isPlaying ? "ÊöÇÂÅú" : "Êí≠Êîæ"}>
                  {playerState.isPlaying ? "‚è∏Ô∏è" : "‚ñ∂Ô∏è"}
                </button>

                <div className='volume-control'>
                  <button
                    className='control-btn volume-btn'
                    onClick={() => handleVolumeChange(playerState.volume > 0 ? 0 : 1)}
                    title={playerState.volume > 0 ? "ÈùôÈü≥" : "ÂèñÊ∂àÈùôÈü≥"}
                  >
                    {playerState.volume === 0 ? "üîá" : playerState.volume < 0.5 ? "üîâ" : "üîä"}
                  </button>
                  <input
                    type='range'
                    min='0'
                    max='1'
                    step='0.1'
                    value={playerState.volume}
                    onChange={e => handleVolumeChange(parseFloat(e.target.value))}
                    className='volume-slider'
                    aria-label='Èü≥ÈáèÊéßÂà∂'
                  />
                </div>

                <div className='time-display'>
                  <span>{formatTime(playerState.currentTime)}</span>
                  <span> / </span>
                  <span>{formatTime(playerState.duration)}</span>
                </div>
              </div>

              <div className='controls-right'>
                <select
                  value={playerState.playbackRate}
                  onChange={e => handlePlaybackRateChange(parseFloat(e.target.value))}
                  className='playback-rate-select'
                  title='Êí≠ÊîæÈÄüÂ∫¶'
                >
                  {playbackRateOptions.map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>

                {isPictureInPictureSupported() && (
                  <button className='control-btn pip-btn' onClick={togglePictureInPicture} title='Áîª‰∏≠Áîª'>
                    üì∫
                  </button>
                )}

                {isFullscreenSupported() && (
                  <button className='control-btn fullscreen-btn' onClick={toggleFullscreen} title={isFullscreen ? "ÈÄÄÂá∫ÂÖ®Â±è" : "ÂÖ®Â±è"}>
                    {isFullscreen ? "üóó" : "üóñ"}
                  </button>
                )}
              </div>
            </div>
          </div>
        </>
      ) : (
        <div className='no-video'>
          <div className='no-video-icon'>üé¨</div>
          <div className='no-video-text'>ËØ∑ÈÄâÊã©Ë¶ÅÊí≠ÊîæÁöÑËßÜÈ¢ë</div>
          <div className='no-video-hint'>‰ªéÊñá‰ª∂ÊµèËßàÂô®‰∏≠ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂ÂºÄÂßãÊí≠Êîæ</div>
        </div>
      )}
    </div>
  );
};

export default VideoPlayer;
